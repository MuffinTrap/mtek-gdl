<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MTek-GDL: gdl::Texture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MTek-GDL<span id="projectnumber">&#160;0.100.4-muffintrap</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegdl.html">gdl</a></li><li class="navelem"><a class="el" href="classgdl_1_1Texture.html">Texture</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">gdl::Texture Class Reference<div class="ingroups"><a class="el" href="group__textureModule.html">Texture Handling Module</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classgdl_1_1Texture.html" title="Texture handling class.">Texture</a> handling class.  
 <a href="classgdl_1_1Texture.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mgdl-wii-texture_8h_source.html">mgdl-wii-texture.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c275e3f186675ff6ed73ccf970e552f" id="r_a6c275e3f186675ff6ed73ccf970e552f"><td class="memItemLeft" align="right" valign="top"><a id="a6c275e3f186675ff6ed73ccf970e552f" name="a6c275e3f186675ff6ed73ccf970e552f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Texture</b> ()</td></tr>
<tr class="memdesc:a6c275e3f186675ff6ed73ccf970e552f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a6c275e3f186675ff6ed73ccf970e552f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c4bcb7462f64c1d20fa69dba3cee8a" id="r_a09c4bcb7462f64c1d20fa69dba3cee8a"><td class="memItemLeft" align="right" valign="top"><a id="a09c4bcb7462f64c1d20fa69dba3cee8a" name="a09c4bcb7462f64c1d20fa69dba3cee8a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~Texture</b> ()</td></tr>
<tr class="memdesc:a09c4bcb7462f64c1d20fa69dba3cee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstructor. <br /></td></tr>
<tr class="separator:a09c4bcb7462f64c1d20fa69dba3cee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af250929cebba0f42562a0fd390449f" id="r_a4af250929cebba0f42562a0fd390449f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a4af250929cebba0f42562a0fd390449f">Create</a> (short xSize, short ySize, u_int filterMode, u_int format)</td></tr>
<tr class="memdesc:a4af250929cebba0f42562a0fd390449f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a texture image.  <br /></td></tr>
<tr class="separator:a4af250929cebba0f42562a0fd390449f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03eb675a00b8c2a15c1b3554c505f5a" id="r_ac03eb675a00b8c2a15c1b3554c505f5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#ac03eb675a00b8c2a15c1b3554c505f5a">CreateMipmapped</a> (short xSize, short ySize, u_int minFilt, u_int magFilt, short maxMipmaps, u_int format)</td></tr>
<tr class="memdesc:ac03eb675a00b8c2a15c1b3554c505f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mipmapped texture image.  <br /></td></tr>
<tr class="separator:ac03eb675a00b8c2a15c1b3554c505f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776e0c9f098628dc11f64fd934f5d41b" id="r_a776e0c9f098628dc11f64fd934f5d41b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a776e0c9f098628dc11f64fd934f5d41b">LoadTexture</a> (const char *fileName)</td></tr>
<tr class="memdesc:a776e0c9f098628dc11f64fd934f5d41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a TPL texture file generated by gxtexconv.  <br /></td></tr>
<tr class="separator:a776e0c9f098628dc11f64fd934f5d41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffe421bcebcea966d0d1a4676967747" id="r_aaffe421bcebcea966d0d1a4676967747"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#aaffe421bcebcea966d0d1a4676967747">ConvertRawImage</a> (short rawXres, short rawYres, <a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> *rawBuff, short srcFormat)</td></tr>
<tr class="memdesc:aaffe421bcebcea966d0d1a4676967747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts raw image data into a texture.  <br /></td></tr>
<tr class="separator:aaffe421bcebcea966d0d1a4676967747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1dc848f2549ea9d7d174655a729405" id="r_a7d1dc848f2549ea9d7d174655a729405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a7d1dc848f2549ea9d7d174655a729405">CopyFromScreen</a> (short x, short y, short width, short height, u_char clearScreen)</td></tr>
<tr class="memdesc:a7d1dc848f2549ea9d7d174655a729405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies pixel data from the active framebuffer.  <br /></td></tr>
<tr class="separator:a7d1dc848f2549ea9d7d174655a729405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653216bcd1509432e28502d9fc7826ce" id="r_a653216bcd1509432e28502d9fc7826ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a653216bcd1509432e28502d9fc7826ce">Delete</a> ()</td></tr>
<tr class="memdesc:a653216bcd1509432e28502d9fc7826ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the texture (but not the object itself).  <br /></td></tr>
<tr class="separator:a653216bcd1509432e28502d9fc7826ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00549987d759d5ab27f3988655c0ed4a" id="r_a00549987d759d5ab27f3988655c0ed4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a00549987d759d5ab27f3988655c0ed4a">Flush</a> ()</td></tr>
<tr class="memdesc:a00549987d759d5ab27f3988655c0ed4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the texture's data block.  <br /></td></tr>
<tr class="separator:a00549987d759d5ab27f3988655c0ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3abec2a91e4e7974de278ffe1ab8db" id="r_a3d3abec2a91e4e7974de278ffe1ab8db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a3d3abec2a91e4e7974de278ffe1ab8db">SetFilterMode</a> (u_int minFilt, u_int magFilt)</td></tr>
<tr class="memdesc:a3d3abec2a91e4e7974de278ffe1ab8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets filter modes to a texture.  <br /></td></tr>
<tr class="separator:a3d3abec2a91e4e7974de278ffe1ab8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f1b421296db6c3d379fd7eeb961e2c" id="r_a73f1b421296db6c3d379fd7eeb961e2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a73f1b421296db6c3d379fd7eeb961e2c">SetWrapMode</a> (u_int wrap_s, u_int wrap_t)</td></tr>
<tr class="memdesc:a73f1b421296db6c3d379fd7eeb961e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wrapping strategy of the texture.  <br /></td></tr>
<tr class="separator:a73f1b421296db6c3d379fd7eeb961e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea26df485f38d9c4a41bdc99a31a663" id="r_a3ea26df485f38d9c4a41bdc99a31a663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a3ea26df485f38d9c4a41bdc99a31a663">PokePixel</a> (short x, short y, u_int col)</td></tr>
<tr class="memdesc:a3ea26df485f38d9c4a41bdc99a31a663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pokes a pixel into the texture.  <br /></td></tr>
<tr class="separator:a3ea26df485f38d9c4a41bdc99a31a663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e4f4aff371c3246f33056bce7236f" id="r_a187e4f4aff371c3246f33056bce7236f"><td class="memItemLeft" align="right" valign="top">u_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a187e4f4aff371c3246f33056bce7236f">PeekPixel</a> (short x, short y)</td></tr>
<tr class="memdesc:a187e4f4aff371c3246f33056bce7236f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks a pixel from the texture.  <br /></td></tr>
<tr class="separator:a187e4f4aff371c3246f33056bce7236f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e31369d2aa932d2435fe5b936aa554" id="r_ae6e31369d2aa932d2435fe5b936aa554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#ae6e31369d2aa932d2435fe5b936aa554">TexAddr</a> ()</td></tr>
<tr class="memdesc:ae6e31369d2aa932d2435fe5b936aa554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pointer to the texture data block.  <br /></td></tr>
<tr class="separator:ae6e31369d2aa932d2435fe5b936aa554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064e4bcbad8e5e6cd7d2e10019af10b6" id="r_a064e4bcbad8e5e6cd7d2e10019af10b6"><td class="memItemLeft" align="right" valign="top">u_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a064e4bcbad8e5e6cd7d2e10019af10b6">TexSize</a> ()</td></tr>
<tr class="memdesc:a064e4bcbad8e5e6cd7d2e10019af10b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the texture data in bytes.  <br /></td></tr>
<tr class="separator:a064e4bcbad8e5e6cd7d2e10019af10b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94f4984e2c136718e935985a9f73cb2" id="r_ad94f4984e2c136718e935985a9f73cb2"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#ad94f4984e2c136718e935985a9f73cb2">TexFmt</a> ()</td></tr>
<tr class="memdesc:ad94f4984e2c136718e935985a9f73cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the texture format index of the texture.  <br /></td></tr>
<tr class="separator:ad94f4984e2c136718e935985a9f73cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93969a997c734de497a49aaaf5fc5734" id="r_a93969a997c734de497a49aaaf5fc5734"><td class="memItemLeft" align="right" valign="top">GXTexObj *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a93969a997c734de497a49aaaf5fc5734">TexObj</a> ()</td></tr>
<tr class="memdesc:a93969a997c734de497a49aaaf5fc5734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the GXTexObj object of the texture.  <br /></td></tr>
<tr class="separator:a93969a997c734de497a49aaaf5fc5734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f9132ac2c5846a345b45a73cafd6bc" id="r_ae8f9132ac2c5846a345b45a73cafd6bc"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#ae8f9132ac2c5846a345b45a73cafd6bc">TXsize</a> ()</td></tr>
<tr class="memdesc:ae8f9132ac2c5846a345b45a73cafd6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the X size of the texture in pixels.  <br /></td></tr>
<tr class="separator:ae8f9132ac2c5846a345b45a73cafd6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db488a025813416117e6f898626d6cb" id="r_a9db488a025813416117e6f898626d6cb"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgdl_1_1Texture.html#a9db488a025813416117e6f898626d6cb">TYsize</a> ()</td></tr>
<tr class="memdesc:a9db488a025813416117e6f898626d6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Y size of the texture in pixels.  <br /></td></tr>
<tr class="separator:a9db488a025813416117e6f898626d6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classgdl_1_1Texture.html" title="Texture handling class.">Texture</a> handling class. </p>
<p>This class is used for conveniently handling textures for storing 2D graphics data such as images, sprites and textures. These are used by the library in image and sprite set classes and can be used by itself to ease loading and converting of textures when developing custom graphics engines. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aaffe421bcebcea966d0d1a4676967747" name="aaffe421bcebcea966d0d1a4676967747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffe421bcebcea966d0d1a4676967747">&#9670;&#160;</a></span>ConvertRawImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Texture::ConvertRawImage </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>rawXres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>rawYres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> *&#160;</td>
          <td class="paramname"><em>rawBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>srcFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts raw image data into a texture. </p>
<p>Converts raw image data into an appropriate texture format specified by gdl::Texture::Create() or gdl::Texture::CreateMipmapped(). If the texture is created with gdl::Texture::CreateMipmapped(), the function will generate mipmaps internally.</p>
<dl class="section note"><dt>Note</dt><dd>If rawXres and rawYres are lower than the created size of the texture, it is automatically padded out with black (or transparent if the texture format has an alpha channel except <a class="el" href="group__textureModule.html#gga4eab0ae68ae32e4797e1b547248bedeaaa4c0ac62fbc5c9a79c46b06f5c23edbf" title="16-bit RGB5A3 pixel format (RGB5 if pixel is opaque, RGB4A3 if pixel is translucent,...">gdl::RGB5A3</a>). </dd>
<dd>
The texture must already be created with gdl::Texture::Create() or gdl::Texture::CreateMipmapped() first. </dd>
<dd>
If the texture is mipmapped, the function would take a bit more time to finish conversion as it had to generate mipmaps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rawXres</td><td>X size of raw image data in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rawYres</td><td>Y size of raw image data in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*rawBuff</td><td>Pointer to raw image data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcFormat</td><td>Format of raw image data (see gdl::ColorFormats). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d1dc848f2549ea9d7d174655a729405" name="a7d1dc848f2549ea9d7d174655a729405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1dc848f2549ea9d7d174655a729405">&#9670;&#160;</a></span>CopyFromScreen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> Texture::CopyFromScreen </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_char&#160;</td>
          <td class="paramname"><em>clearScreen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies pixel data from the active framebuffer. </p>
<p>This function copies pixels from the active framebuffer to be used as a texture which is useful for doing render-to-texture based effects. Take note that the range at which you can capture depends on the current video mode that the system is running on and is best to take into account of the actual framebuffer resolution using the variables <a class="el" href="namespacegdl_1_1wii.html#a3ff1d9a877f5c3c8e20d889656580399" title="Pointer to video and renderer settings (see GXRModeObj for details).">gdl::wii::rmode</a>-&gt;fbWidth and <a class="el" href="namespacegdl_1_1wii.html#a3ff1d9a877f5c3c8e20d889656580399" title="Pointer to video and renderer settings (see GXRModeObj for details).">gdl::wii::rmode</a>-&gt;efbHeight.</p>
<dl class="section note"><dt>Note</dt><dd>The texture must already be created with gdl::Texture::Create(). </dd>
<dd>
This function is GPU intensive which means calling this function too many times will cause a big performance drop. </dd>
<dd>
The copy region offset and size is specified in framebuffer pixels which means that the specified resolution is always relative to the actual resolution from <a class="el" href="namespacegdl_1_1wii.html#a3ff1d9a877f5c3c8e20d889656580399" title="Pointer to video and renderer settings (see GXRModeObj for details).">gdl::wii::rmode</a> and is never affected by the current projection matrix.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>X offset of screen to copy from in framebuffer pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Y offset of screen to copy from in framebuffer pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of copy region in framebuffer pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of copy region in framebuffer pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clearScreen</td><td>If true, the framebuffer is cleared after copying. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4af250929cebba0f42562a0fd390449f" name="a4af250929cebba0f42562a0fd390449f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af250929cebba0f42562a0fd390449f">&#9670;&#160;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Texture::Create </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>xSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>ySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>filterMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a texture image. </p>
<p>Creates a memory buffer for storing texture data.</p>
<dl class="section note"><dt>Note</dt><dd>The size of the texture must be a multiple of 4 in both dimensions and must not be greater than 1024 pixels as that is the maximum texture resolution the GX can handle. </dd>
<dd>
If the texture is already created, it is simply reallocated but it is not recommended to keep recreating the texture to prevent too much memory fragmentation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSize</td><td>X size of texture in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ySize</td><td>Y size of texture in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterMode</td><td>Filtering mode (see gdl::TextureFilterModes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td><a class="el" href="classgdl_1_1Texture.html" title="Texture handling class.">Texture</a> format (see <a class="el" href="group__textureModule.html#ga4eab0ae68ae32e4797e1b547248bedea">gdl::TextureFormatModes</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the texture had been created successfully otherwise there is not enough free memory to create the texture buffer. </dd></dl>

</div>
</div>
<a id="ac03eb675a00b8c2a15c1b3554c505f5a" name="ac03eb675a00b8c2a15c1b3554c505f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03eb675a00b8c2a15c1b3554c505f5a">&#9670;&#160;</a></span>CreateMipmapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Texture::CreateMipmapped </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>xSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>ySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>minFilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>magFilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>maxMipmaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mipmapped texture image. </p>
<p>Unlike gdl::Texture::Create(), this function creates a mipmapped texture buffer which improves rendering quality (and in some cases performance) when the texture is drawn smaller than its original resolution. It is recommended to use mipmapped textures for large 3D geometry or images that get scaled up or down immensely and you don't want it to look all jagged and pixelated when it gets small enough.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike non-mipmapped textures which can be of any size as long as its a multiple of 4x4 pixels, mipmapped textures however must be a power of two to work correctly. </dd>
<dd>
Mipmapped textures take up roughly 33% more memory (with 9 mipmap levels) than that of a non mipmapped texture so you must determine the number of mipmaps necessary to generate such as if the image doesn't get downscaled so much, a single mipmap level is good enough for it. Using texture formats that are of a lower color depth such as <a class="el" href="group__textureModule.html#gga4eab0ae68ae32e4797e1b547248bedeaad0e91dbed3a1d4d4830b275cceb63ce9" title="16-bit RGB565 pixel format (2 bytes per pixel).">gdl::RGB565</a> or <a class="el" href="group__textureModule.html#gga4eab0ae68ae32e4797e1b547248bedeaaa4c0ac62fbc5c9a79c46b06f5c23edbf" title="16-bit RGB5A3 pixel format (RGB5 if pixel is opaque, RGB4A3 if pixel is translucent,...">gdl::RGB5A3</a> will help as well with a slight loss of color definition. </dd>
<dd>
The smallest mipmap resolution the library will allow is 4x4 pixels (same size as a texture block) so a maximum of 9 mipmaps can be generated from a 1024x1024 texture image. If the texture is too small to reach the specified number of maximum mipmaps, it will simply generate less mipmaps than that specified. </dd>
<dd>
By default, mipmaped textures are set to have an anisotropy level of 4 and edge LOD computation enabled for the best (but most intensive) mipmapping quality. You can change these using GX commands and the gdl::Texture::TexObj() function to retrieve the GXTexObj struct of the texture.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xSize</td><td>X size of texture in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ySize</td><td>Y size of texture in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minFilt</td><td>Filtering mode when texture is drawn less than the original resolution (see gdl::TextureFilterModes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">magFilt</td><td>Filtering mode when texture is drawn higher than the original resolution (see gdl::TextureFilterModes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxMipmaps</td><td>Number of mipmaps to generate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td><a class="el" href="classgdl_1_1Texture.html" title="Texture handling class.">Texture</a> format (see <a class="el" href="group__textureModule.html#ga4eab0ae68ae32e4797e1b547248bedea">gdl::TextureFormatModes</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the texture had been allocated successfully otherwise there is not enough free memory to create the texture. </dd></dl>

</div>
</div>
<a id="a653216bcd1509432e28502d9fc7826ce" name="a653216bcd1509432e28502d9fc7826ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653216bcd1509432e28502d9fc7826ce">&#9670;&#160;</a></span>Delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> Texture::Delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the texture (but not the object itself). </p>
<p>This function deallocates the texture data block associated to it and resets various parameters of the texture to 0.</p>
<dl class="section note"><dt>Note</dt><dd>It is unnecessary to call this function before deconstructing the object as the texture is automatically freed upon deconstruction... It is implemented for certain purposes. </dd></dl>

</div>
</div>
<a id="a00549987d759d5ab27f3988655c0ed4a" name="a00549987d759d5ab27f3988655c0ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00549987d759d5ab27f3988655c0ed4a">&#9670;&#160;</a></span>Flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> Texture::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the texture's data block. </p>
<p>If gdl::SetAutoFlush() is set to false, you must call this function whenever you modify the contents of the texture data block otherwise, the changes will not take effect or it will initially appear as corrupted blocks. </p>

</div>
</div>
<a id="a776e0c9f098628dc11f64fd934f5d41b" name="a776e0c9f098628dc11f64fd934f5d41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776e0c9f098628dc11f64fd934f5d41b">&#9670;&#160;</a></span>LoadTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Texture::LoadTexture </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a TPL texture file generated by gxtexconv. </p>
<p>This function loads a texture from a TPL texture file. TPL actually stands for <a class="el" href="classgdl_1_1Texture.html" title="Texture handling class.">Texture</a> PaLette as the file format can contain multiple textures at once. However, this function only supports single texture TPL files currently. If the texture has mipmaps, trilinear mipmap filtering is set.</p>
<dl class="section note"><dt>Note</dt><dd>The texture does not need to be created first when loading a TPL file. </dd>
<dd>
TPL files are best used for handling textures in special formats which are not supported by the library such as DXT1 compressed textures. However, Color Index textures are not supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>File name of TPL texture file to load.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the texture was successfully loaded otherwise an error occured. </dd></dl>

</div>
</div>
<a id="a187e4f4aff371c3246f33056bce7236f" name="a187e4f4aff371c3246f33056bce7236f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187e4f4aff371c3246f33056bce7236f">&#9670;&#160;</a></span>PeekPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int Texture::PeekPixel </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peeks a pixel from the texture. </p>
<p>Peeks a pixel from the texture for generating things from images</p>
<dl class="section note"><dt>Note</dt><dd>This function is only effective on non-mipmapped and non-specialty format textures. </dd>
<dd>
If you peek a pixel from an I4/I8 format texture, the color value will be only be in a range from 0 to 255. If the texture is an IA4/IA8, use the IA() color macro.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>X offset of pixel to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Y offset of pixel to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Color of pixel (use the <a class="el" href="mgdl-types_8h.html#ab3a295dcd815c8b9bd1507415238b482ae75845ff0980839032f4a78a0d42753c" title="32-bit true-color RGBA (R8G8B8A8).">RGBA()</a> or IA() macros for this). </dd></dl>

</div>
</div>
<a id="a3ea26df485f38d9c4a41bdc99a31a663" name="a3ea26df485f38d9c4a41bdc99a31a663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea26df485f38d9c4a41bdc99a31a663">&#9670;&#160;</a></span>PokePixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> Texture::PokePixel </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pokes a pixel into the texture. </p>
<p>Pokes a pixel into a texture useful for procedurally generating textures easily.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only effective on non-mipmapped and non-specialty format textures. Also, pixels drawn outside the texture are simply clipped. </dd>
<dd>
If gdl::SetAutoFlush() is set to true (false by default), this function will perform a lot slower when doing a lot of texture changes. For best performance, set gdl::SetAutoFlush() to false and call gdl::Texture::Flush() after doing such changes. </dd>
<dd>
If you poke a pixel to an I4/I8 format texture, the color value must only be a range from 0 to 255. If the texture is an IA4/IA8, use the IA() color macro.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>X offset of pixel to draw to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Y offset of pixel to draw to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>Color of pixel (use the <a class="el" href="mgdl-types_8h.html#ab3a295dcd815c8b9bd1507415238b482ae75845ff0980839032f4a78a0d42753c" title="32-bit true-color RGBA (R8G8B8A8).">RGBA()</a> or IA() macros for this). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d3abec2a91e4e7974de278ffe1ab8db" name="a3d3abec2a91e4e7974de278ffe1ab8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3abec2a91e4e7974de278ffe1ab8db">&#9670;&#160;</a></span>SetFilterMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> Texture::SetFilterMode </td>
          <td>(</td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>minFilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>magFilt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets filter modes to a texture. </p>
<dl class="section note"><dt>Note</dt><dd>magFilt can only be either gdl::Nearest or gdl::Linear.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minFilt</td><td>Filter mode when texture is &lt; 1.0 of original size (see gdl::TextureFilterModes for more filter modes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">magFilt</td><td>Filter mode when texture is &gt;= 1.0 of original size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73f1b421296db6c3d379fd7eeb961e2c" name="a73f1b421296db6c3d379fd7eeb961e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f1b421296db6c3d379fd7eeb961e2c">&#9670;&#160;</a></span>SetWrapMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> Texture::SetWrapMode </td>
          <td>(</td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>wrap_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&#160;</td>
          <td class="paramname"><em>wrap_t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the wrapping strategy of the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wrap_s</td><td><a class="el" href="classgdl_1_1Texture.html" title="Texture handling class.">Texture</a> wrapping strategy in the S (or U) direction (see gdl::TextureWrapModes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wrap_t</td><td><a class="el" href="classgdl_1_1Texture.html" title="Texture handling class.">Texture</a> wrapping strategy in the T (or V) direction (see gdl::TextureWrapModes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6e31369d2aa932d2435fe5b936aa554" name="ae6e31369d2aa932d2435fe5b936aa554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e31369d2aa932d2435fe5b936aa554">&#9670;&#160;</a></span>TexAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__inputModule.html#gaf3869f5f8c2dd5eeec3ab4c5b8f0475f">void</a> * Texture::TexAddr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the pointer to the texture data block. </p>
<dl class="section note"><dt>Note</dt><dd>If you modify the contents of the memory block, you must flush it either with gdl::Texture::Flush() or DCFlushRange(). </dd>
<dd>
The pointer is always aligned in 32 byte increments.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to texture data (NULL if texture has not yet been created). </dd></dl>

</div>
</div>
<a id="ad94f4984e2c136718e935985a9f73cb2" name="ad94f4984e2c136718e935985a9f73cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94f4984e2c136718e935985a9f73cb2">&#9670;&#160;</a></span>TexFmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short Texture::TexFmt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the texture format index of the texture. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgdl_1_1Texture.html" title="Texture handling class.">Texture</a> format (see <a class="el" href="group__textureModule.html#ga4eab0ae68ae32e4797e1b547248bedea">gdl::TextureFormatModes</a>). </dd></dl>

</div>
</div>
<a id="a93969a997c734de497a49aaaf5fc5734" name="a93969a997c734de497a49aaaf5fc5734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93969a997c734de497a49aaaf5fc5734">&#9670;&#160;</a></span>TexObj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GXTexObj * Texture::TexObj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the GXTexObj object of the texture. </p>
<p>Useful if you want to set the texture with <a href="http://libogc.devkitpro.org/gx_8h.html#ad6388b0e4a0f2ffb5daa16a8851fa567"><b>GX_LoadTexObj()</b></a> to be used as your current texture object.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a GXTexObj object, NULL if texture is not yet created. </dd></dl>

</div>
</div>
<a id="a064e4bcbad8e5e6cd7d2e10019af10b6" name="a064e4bcbad8e5e6cd7d2e10019af10b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064e4bcbad8e5e6cd7d2e10019af10b6">&#9670;&#160;</a></span>TexSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int Texture::TexSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the texture data in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of texture data in bytes (0 if texture is not yet created). </dd></dl>

</div>
</div>
<a id="ae8f9132ac2c5846a345b45a73cafd6bc" name="ae8f9132ac2c5846a345b45a73cafd6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f9132ac2c5846a345b45a73cafd6bc">&#9670;&#160;</a></span>TXsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short Texture::TXsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the X size of the texture in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>X size of texture in pixels, 0 if texture is not yet created. </dd></dl>

</div>
</div>
<a id="a9db488a025813416117e6f898626d6cb" name="a9db488a025813416117e6f898626d6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db488a025813416117e6f898626d6cb">&#9670;&#160;</a></span>TYsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short Texture::TYsize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Y size of the texture in pixels. </p>
<dl class="section return"><dt>Returns</dt><dd>Y size of texture in pixels, 0 if texture is not yet created. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mgdl/wii/<a class="el" href="mgdl-wii-texture_8h_source.html">mgdl-wii-texture.h</a></li>
<li>source/wii/<b>wii-texture.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
